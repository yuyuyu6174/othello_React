(function(){"use strict";const B=[[100,-25,10,5,5,10,-25,100],[-25,-50,1,1,1,1,-50,-25],[10,1,3,2,2,3,1,10],[5,1,2,1,1,2,1,5],[5,1,2,1,1,2,1,5],[10,1,3,2,2,3,1,10],[-25,-50,1,1,1,1,-50,-25],[100,-25,10,5,5,10,-25,100]];function C(t){let e=0,i=0;for(let n of t)for(let r of n)r===E?e++:r===P&&i++;return{white:e,black:i}}function A(t){const e=Array.from({length:y},()=>Array(y).fill(0)),i=[[1,0],[-1,0],[0,1],[0,-1],[1,1],[-1,-1],[1,-1],[-1,1]],n=(r,s,a)=>{for(let[v,o]of i){let l=r+v,m=s+o;for(;l>=0&&l<y&&m>=0&&m<y;){if(t[m][l]!==a)return!1;l+=v,m+=o}}return!0};for(let r=0;r<y;r++)for(let s=0;s<y;s++){const a=t[r][s];a!==W&&n(s,r,a)&&(e[r][s]=a)}return e}function M(t,e){const i=3-e;let n=0;for(let r=0;r<y;r++)for(let s=0;s<y;s++)t[r][s]===e?n++:t[r][s]===i&&n--;return n}function g(t,e,i={}){return w(t,e,i,!0)}function I(t,e,i={}){return w(t,e,i,!1)}function w(t,e,i={},n=!0){const r=3-e;let s=0;const a=i.weights||B,v=i.useWeights!==!1,o=n?20:i.stableStoneBonus??20,l=n?40:i.parityWeight??40,m=n?30:i.xSquarePenalty??50,f=n?30:i.trapPenalty??30;if(v)for(let c=0;c<y;c++)for(let u=0;u<y;u++){const p=t[c][u];p===e?s+=a[c][u]:p===r&&(s-=a[c][u])}if(i.evaluateStableStones){const c=A(t);for(let u=0;u<y;u++)for(let p=0;p<y;p++)c[u][p]===e?s+=o:c[u][p]===r&&(s-=o)}if(i.considerParity&&t.flat().filter(u=>u===W).length<=16){const u=C(t),p=e===E?u.white-u.black:u.black-u.white;s+=l*Math.sign(p)}if(i.penalizeXSquare){const c=[[1,1],[6,1],[1,6],[6,6]];for(const[u,p]of c)t[p][u]===e&&(s-=m),t[p][u]===r&&(s+=m)}if(i.avoidCornerTrap){const c=[[0,1],[1,0],[1,1],[0,6],[1,7],[1,6],[6,0],[6,1],[7,1],[6,6],[6,7],[7,6]];for(const[u,p]of c)t[p][u]===e&&(s-=f),t[p][u]===r&&(s+=f)}return s}const y=8,W=0,P=1,E=2,q={1:{visible:!0,name:"弱",comment:"浅い読みとシンプルな評価（初心者向け）",type:"minimax",depth:1,evaluator:M},2:{visible:!0,name:"中",comment:"標準的な深さのミニマックス探索",type:"minimax",depth:2,evaluator:M},3:{visible:!0,name:"強",comment:"さらに深い探索で安定したプレイ",type:"minimax",depth:3,evaluator:M},4:{visible:!0,name:"最強",comment:"深さ6の高精度ミニマックス探索（実践向け）",type:"minimax",depth:6,evaluator:g,useWeights:!1,avoidCornerTrap:!0,penalizeXSquare:!0},101:{visible:!0,name:"AI Test1",comment:"戦略評価を導入",type:"minimax",depth:6,evaluator:g,useWeights:!0,avoidCornerTrap:!0,evaluateStableStones:!0,considerParity:!0,penalizeXSquare:!0},102:{visible:!0,name:"AI Test2",comment:"残りマス数に応じて深さを調整（動的読み）",type:"minimax",dynamicDepth:!0,depthTable:[{max:20,depth:7},{max:40,depth:5},{max:64,depth:4}],evaluator:g,useWeights:!0,avoidCornerTrap:!0,evaluateStableStones:!0,considerParity:!0,penalizeXSquare:!0},103:{visible:!0,name:"AI Test3",comment:"反復深化探索（時間制限あり）",type:"iterative",timeLimit:800,evaluator:g,useWeights:!0,avoidCornerTrap:!0,evaluateStableStones:!0,considerParity:!0,penalizeXSquare:!0},104:{visible:!0,name:"AI Test4",comment:"MCTS（モンテカルロ木探索）を使用",type:"mcts",simulations:1e3,timeLimit:800,explorationConstant:1.1,evaluator:I,useWeights:!0,avoidCornerTrap:!0,evaluateStableStones:!0,considerParity:!0,penalizeXSquare:!0,parityWeight:50,stableStoneBonus:30,xSquarePenalty:60},105:{visible:!1,name:"AI Test5",comment:"評価カスタムを実装",type:"minimax",dynamicDepth:!0,depthTable:[{max:20,depth:8},{max:40,depth:6},{max:64,depth:5}],evaluator:I,useWeights:!0,weights:[[100,-40,20,5,5,20,-40,100],[-40,-80,-1,-1,-1,-1,-80,-40],[20,-1,5,1,1,5,-1,20],[5,-1,1,0,0,1,-1,5],[5,-1,1,0,0,1,-1,5],[20,-1,5,1,1,5,-1,20],[-40,-80,-1,-1,-1,-1,-80,-40],[100,-40,20,5,5,20,-40,100]],avoidCornerTrap:!0,evaluateStableStones:!0,considerParity:!0,penalizeXSquare:!0,parityWeight:40,stableStoneBonus:20,xSquarePenalty:50,useEndgameSolver:!0,endgame:{maxEmpty:12,usePruning:!0}},106:{visible:!0,name:"AI Test6",comment:"残り12マスになると完全終局読みを使用",type:"minimax",dynamicDepth:!0,depthTable:[{max:20,depth:8},{max:40,depth:6},{max:64,depth:5}],evaluator:g,useWeights:!0,avoidCornerTrap:!0,evaluateStableStones:!0,considerParity:!0,penalizeXSquare:!0,useEndgameSolver:!0,endgame:{maxEmpty:12,usePruning:!0}},999:{visible:!0,name:"Noob",comment:"最深読みと戦略フル活用。",type:"minimax",dynamicDepth:!0,depthTable:[{max:20,depth:8},{max:40,depth:6},{max:64,depth:5}],evaluator:I,useWeights:!0,weights:[[100,-40,20,5,5,20,-40,100],[-40,-80,-1,-1,-1,-1,-80,-40],[20,-1,5,1,1,5,-1,20],[5,-1,1,0,0,1,-1,5],[5,-1,1,0,0,1,-1,5],[20,-1,5,1,1,5,-1,20],[-40,-80,-1,-1,-1,-1,-80,-40],[100,-40,20,5,5,20,-40,100]],avoidCornerTrap:!0,evaluateStableStones:!0,considerParity:!0,penalizeXSquare:!0,parityWeight:60,stableStoneBonus:30,xSquarePenalty:60,trapPenalty:40,useEndgameSolver:!0,endgame:{maxEmpty:12,usePruning:!0}}},S=8,k=0,X=[[1,0],[-1,0],[0,1],[0,-1],[1,1],[-1,-1],[1,-1],[-1,1]];function z(t,e,i,n){if(n[e][t]!==k)return[];const r=[],s=3-i;for(const[a,v]of X){let o=t+a,l=e+v;const m=[];for(;o>=0&&o<S&&l>=0&&l<S&&n[l][o]===s;)m.push([o,l]),o+=a,l+=v;o>=0&&o<S&&l>=0&&l<S&&n[l][o]===i&&r.push(...m)}return r}function D(t,e){const i=[];for(let n=0;n<S;n++)for(let r=0;r<S;r++){const s=z(r,n,t,e);s.length>0&&i.push({x:r,y:n,flips:s})}return i}function x(t,e){return D(t,e)}function h(t,e,i){const n=t.map(r=>[...r]);n[e.y][e.x]=i;for(const[r,s]of e.flips)n[s][r]=i;return n}const d=new Map;function L(t,e,i){const n=q[i]||q[1],r=a=>n.evaluator(a,e,n),s=t.flat().filter(a=>a===0).length;if(n.useEndgameSolver&&n.endgame&&s<=(n.endgame.maxEmpty??12))return F(t,e,n);if(n.type==="minimax"){const a=n.dynamicDepth?G(s,n.depthTable||[]):n.depth||2;return N(t,e,a,r)}return n.type==="iterative"?_(t,e,n.timeLimit||1e3,r):null}function G(t,e){for(let i of e)if(t<=i.max)return i.depth;return 2}function N(t,e,i,n,r){const s=x(e,t);if(s.length===0)return null;let a=null,v=-1/0;for(const o of s){const l=h(t,o,e),m=T(l,3-e,i-1,-1/0,1/0,!1,n);m>v&&(v=m,a=o)}return a}function T(t,e,i,n,r,s,a,v){const o=JSON.stringify(t)+e+i;if(d.has(o))return d.get(o);const l=x(e,t);if(i===0||l.length===0){const f=a(t);return d.set(o,f),f}const m=l.map(f=>{const c=h(t,f,e),u=a(c);return{move:f,score:u}}).sort((f,c)=>s?c.score-f.score:f.score-c.score);if(s){let f=-1/0;for(const{move:c}of m){const u=h(t,c,e),p=T(u,3-e,i-1,n,r,!1,a);if(f=Math.max(f,p),n=Math.max(n,p),r<=n)break}return d.set(o,f),f}else{let f=1/0;for(const{move:c}of m){const u=h(t,c,e),p=T(u,3-e,i-1,n,r,!0,a);if(f=Math.min(f,p),r=Math.min(r,p),r<=n)break}return d.set(o,f),f}}function _(t,e,i,n,r){const s=x(e,t);let a=null,v=-1/0;const o=Date.now();let l=1;for(;Date.now()-o<i;){for(const m of s){const f=h(t,m,e),c=T(f,3-e,l,-1/0,1/0,!1,n);c>v&&(v=c,a=m)}l++}return a}function F(t,e,i){const n=x(e,t);if(n.length===0)return null;let r=null,s=-1/0;for(const a of n){const v=h(t,a,e),o=-b(v,3-e,i);o>s&&(s=o,r=a)}return r}function b(t,e,i,n){var a;const r=x(e,t);if(r.length===0)if(x(3-e,t).length===0){const o=t.flat().filter(m=>m===P).length,l=t.flat().filter(m=>m===E).length;return e===P?o-l:l-o}else return-b(t,3-e,i);let s=-1/0;for(const v of r){const o=h(t,v,e),l=-b(o,3-e,i);if(s=Math.max(s,l),(a=i.endgame)!=null&&a.usePruning&&s>=64)break}return s}self.onmessage=function(t){const{board:e,turn:i,level:n}=t.data,r=L(e,i,n);postMessage(r)}})();
