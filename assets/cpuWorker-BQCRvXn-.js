(function(){"use strict";function X(n){let t=0,s=0;for(let r of n)for(let e of r)e===C?t++:e===T&&s++;return{white:t,black:s}}function z(n){const t=Array.from({length:h},()=>Array(h).fill(0)),s=[[1,0],[-1,0],[0,1],[0,-1],[1,1],[-1,-1],[1,-1],[-1,1]],r=(e,o,u)=>{for(let[l,f]of s){let c=e+l,p=o+f;for(;c>=0&&c<h&&p>=0&&p<h;){if(n[p][c]!==u)return!1;c+=l,p+=f}}return!0};for(let e=0;e<h;e++)for(let o=0;o<h;o++){const u=n[e][o];u!==W&&r(o,e,u)&&(t[e][o]=u)}return t}function b(n,t){const s=3-t;let r=0;for(let e=0;e<h;e++)for(let o=0;o<h;o++)n[e][o]===t?r++:n[e][o]===s&&r--;return r}function M(n,t,s={}){return q(n,t,s)}function B(n,t,s={}){return q(n,t,s)}function q(n,t,s={}){const r=3-t;let e=0;const o=s.weights??g.weights,u=s.useWeights!==!1,l=s.stableStoneBonus??g.stableStoneBonus,f=s.parityWeight??g.parityWeight,c=s.xSquarePenalty??g.xSquarePenalty,p=s.trapPenalty??g.trapPenalty;if(u)for(let i=0;i<h;i++)for(let a=0;a<h;a++){const m=n[i][a];m===t?e+=o[i][a]:m===r&&(e-=o[i][a])}if(s.evaluateStableStones){const i=z(n);for(let a=0;a<h;a++)for(let m=0;m<h;m++)i[a][m]===t?e+=l:i[a][m]===r&&(e-=l)}if(s.considerParity&&n.flat().filter(a=>a===W).length<=16){const a=X(n),m=t===C?a.white-a.black:a.black-a.white;e+=f*Math.sign(m)}if(s.penalizeXSquare){const i=[[1,1],[6,1],[1,6],[6,6]];for(const[a,m]of i)n[m][a]===t&&(e-=c),n[m][a]===r&&(e+=c)}if(s.avoidCornerTrap){const i=[[0,1],[1,0],[1,1],[0,6],[1,7],[1,6],[6,0],[6,1],[7,1],[6,6],[6,7],[7,6]];for(const[a,m]of i)n[m][a]===t&&(e-=p),n[m][a]===r&&(e+=p)}return e}const h=8,W=0,T=1,C=2,g={visible:!0,depth:2,weights:[[100,-25,10,5,5,10,-25,100],[-25,-50,1,1,1,1,-50,-25],[10,1,3,2,2,3,1,10],[5,1,2,1,1,2,1,5],[5,1,2,1,1,2,1,5],[10,1,3,2,2,3,1,10],[-25,-50,1,1,1,1,-50,-25],[100,-25,10,5,5,10,-25,100]],parityWeight:40,stableStoneBonus:20,xSquarePenalty:30,trapPenalty:30,endgame:{maxEmpty:12,usePruning:!0}},A={1:{visible:!0,name:"弱",comment:"浅い読みとシンプルな評価（初心者向け）",type:"minimax",depth:1,evaluator:b},2:{visible:!0,name:"中",comment:"標準的な深さのミニマックス探索",type:"minimax",depth:2,evaluator:b},3:{visible:!0,name:"強",comment:"さらに深い探索で安定したプレイ",type:"minimax",depth:3,evaluator:b},4:{visible:!0,name:"最強",comment:"深さ6の高精度ミニマックス探索（実践向け）",type:"minimax",depth:6,evaluator:M,useWeights:!1,avoidCornerTrap:!0,penalizeXSquare:!0},101:{visible:!0,name:"AI Test1",comment:"戦略評価を導入",type:"minimax",depth:6,evaluator:M,useWeights:!0,avoidCornerTrap:!0,evaluateStableStones:!0,considerParity:!0,penalizeXSquare:!0},102:{visible:!0,name:"AI Test2",comment:"残りマス数に応じて深さを調整（動的読み）",type:"minimax",dynamicDepth:!0,depthTable:[{max:20,depth:7},{max:40,depth:5},{max:64,depth:4}],evaluator:M,useWeights:!0,avoidCornerTrap:!0,evaluateStableStones:!0,considerParity:!0,penalizeXSquare:!0},103:{visible:!0,name:"AI Test3",comment:"反復深化探索（時間制限あり）",type:"iterative",timeLimit:800,evaluator:M,useWeights:!0,avoidCornerTrap:!0,evaluateStableStones:!0,considerParity:!0,penalizeXSquare:!0},104:{visible:!0,name:"AI Test4",comment:"MCTS（モンテカルロ木探索）を使用",type:"mcts",simulations:1e3,timeLimit:800,explorationConstant:1.1,evaluator:B,useWeights:!0,avoidCornerTrap:!0,evaluateStableStones:!0,considerParity:!0,penalizeXSquare:!0,parityWeight:50,stableStoneBonus:30,xSquarePenalty:60},105:{visible:!1,name:"AI Test5",comment:"評価カスタムを実装",type:"minimax",dynamicDepth:!0,depthTable:[{max:20,depth:8},{max:40,depth:6},{max:64,depth:5}],evaluator:B,useWeights:!0,weights:[[100,-40,20,5,5,20,-40,100],[-40,-80,-1,-1,-1,-1,-80,-40],[20,-1,5,1,1,5,-1,20],[5,-1,1,0,0,1,-1,5],[5,-1,1,0,0,1,-1,5],[20,-1,5,1,1,5,-1,20],[-40,-80,-1,-1,-1,-1,-80,-40],[100,-40,20,5,5,20,-40,100]],avoidCornerTrap:!0,evaluateStableStones:!0,considerParity:!0,penalizeXSquare:!0,parityWeight:40,stableStoneBonus:20,xSquarePenalty:50,useEndgameSolver:!0,endgame:{maxEmpty:12,usePruning:!0}},106:{visible:!0,name:"AI Test6",comment:"残り12マスになると完全終局読みを使用",type:"minimax",dynamicDepth:!0,depthTable:[{max:20,depth:8},{max:40,depth:6},{max:64,depth:5}],evaluator:M,useWeights:!0,avoidCornerTrap:!0,evaluateStableStones:!0,considerParity:!0,penalizeXSquare:!0,useEndgameSolver:!0,endgame:{maxEmpty:12,usePruning:!0}},999:{visible:!0,name:"Noob",comment:"最深読みと戦略フル活用。",type:"minimax",dynamicDepth:!0,depthTable:[{max:20,depth:8},{max:40,depth:6},{max:64,depth:5}],evaluator:B,useWeights:!0,weights:[[100,-40,20,5,5,20,-40,100],[-40,-80,-1,-1,-1,-1,-80,-40],[20,-1,5,1,1,5,-1,20],[5,-1,1,0,0,1,-1,5],[5,-1,1,0,0,1,-1,5],[20,-1,5,1,1,5,-1,20],[-40,-80,-1,-1,-1,-1,-80,-40],[100,-40,20,5,5,20,-40,100]],avoidCornerTrap:!0,evaluateStableStones:!0,considerParity:!0,penalizeXSquare:!0,parityWeight:60,stableStoneBonus:30,xSquarePenalty:60,trapPenalty:40,useEndgameSolver:!0,endgame:{maxEmpty:12,usePruning:!0}}},S=8,L=0,N=1,$=2,O=[[1,0],[-1,0],[0,1],[0,-1],[1,1],[-1,-1],[1,-1],[-1,1]];function _(n,t,s,r){if(r[t][n]!==L)return[];const e=[],o=3-s;for(const[u,l]of O){let f=n+u,c=t+l;const p=[];for(;f>=0&&f<S&&c>=0&&c<S&&r[c][f]===o;)p.push([f,c]),f+=u,c+=l;f>=0&&f<S&&c>=0&&c<S&&r[c][f]===s&&e.push(...p)}return e}function F(n,t){const s=[];for(let r=0;r<S;r++)for(let e=0;e<S;e++){const o=_(e,r,n,t);o.length>0&&s.push({x:e,y:r,flips:o})}return s}function y(n,t){return F(n,t)}function v(n,t,s){const r=n.map(e=>[...e]);r[t.y][t.x]=s;for(const[e,o]of t.flips)r[o][e]=s;return r}function G(n){let t=0,s=0;for(const r of n)for(const e of r)e===N?t++:e===$&&s++;return{black:t,white:s}}const w=new Map,I=new Map;function V(n,t,s){const r=A[s]||A[1],e={...g,...r,endgame:{...g.endgame,...r.endgame||{}}},o=l=>e.evaluator(l,t,e),u=n.flat().filter(l=>l===0).length;if(e.useEndgameSolver&&e.endgame&&u<=(e.endgame.maxEmpty??12))return Y(n,t,e);if(e.type==="minimax"){const l=e.dynamicDepth?H(u,e.depthTable||[]):e.depth??g.depth??2;return J(n,t,l,o)}return e.type==="iterative"?K(n,t,e.timeLimit||1e3,o):e.type==="mcts"?j(n,t,e):null}function H(n,t){for(let s of t)if(n<=s.max)return s.depth;return 2}function J(n,t,s,r,e){const o=y(t,n);if(o.length===0)return null;let u=null,l=-1/0;for(const f of o){const c=v(n,f,t),p=P(c,3-t,s-1,-1/0,1/0,!1,r);p>l&&(l=p,u=f)}return u}function P(n,t,s,r,e,o,u,l){const f=JSON.stringify(n)+t+s;if(w.has(f))return w.get(f);const c=y(t,n);if(s===0||c.length===0){const i=u(n);return w.set(f,i),i}const p=c.map(i=>{const a=v(n,i,t),m=u(a);return{move:i,score:m}}).sort((i,a)=>o?a.score-i.score:i.score-a.score);if(o){let i=-1/0;for(const{move:a}of p){const m=v(n,a,t),d=P(m,3-t,s-1,r,e,!1,u);if(i=Math.max(i,d),r=Math.max(r,d),e<=r)break}return w.set(f,i),i}else{let i=1/0;for(const{move:a}of p){const m=v(n,a,t),d=P(m,3-t,s-1,r,e,!0,u);if(i=Math.min(i,d),e=Math.min(e,d),e<=r)break}return w.set(f,i),i}}function K(n,t,s,r,e){const o=y(t,n);let u=null,l=-1/0;const f=Date.now();let c=1;for(;Date.now()-f<s;){for(const p of o){const i=v(n,p,t),a=P(i,3-t,c,-1/0,1/0,!1,r);a>l&&(l=a,u=p)}c++}return u}function Y(n,t,s){const r=y(t,n);if(r.length===0)return null;let e=null,o=-1/0;const u=r.map(l=>{const f=v(n,l,t),c=s.evaluator(f,t,s);return{move:l,score:c}}).sort((l,f)=>f.score-l.score);for(const{move:l}of u){const f=v(n,l,t),c=-E(f,3-t,s,!1,-1/0,1/0);c>o&&(o=c,e=l)}return e}function E(n,t,s,r,e=-1/0,o=1/0){var p;const u=JSON.stringify(n)+t;if(I.has(u))return I.get(u);const l=y(t,n);if(l.length===0)if(y(3-t,n).length===0){const a=n.flat().filter(x=>x===T).length,m=n.flat().filter(x=>x===C).length,d=t===T?a-m:m-a;return I.set(u,d),d}else{const a=-E(n,3-t,s,!0,-o,-e);return I.set(u,a),a}const f=l.map(i=>{const a=v(n,i,t),m=s.evaluator(a,t,s);return{move:i,score:m}}).sort((i,a)=>a.score-i.score);let c=-1/0;for(const{move:i}of f){const a=v(n,i,t),m=-E(a,3-t,s,!1,-o,-e);if(c=Math.max(c,m),e=Math.max(e,m),e>=o||(p=s.endgame)!=null&&p.usePruning&&c>=64)break}return I.set(u,c),c}function Z(n,t){let s=-1/0,r=n.children[0];for(const e of n.children){const o=e.visits===0?1/0:e.wins/e.visits+t*Math.sqrt(Math.log(n.visits)/e.visits);o>s&&(s=o,r=e)}return r}function U(n,t,s){let r=n.map(l=>[...l]),e=t;for(;;){const l=y(e,r);if(l.length===0){if(y(3-e,r).length===0)break;e=3-e;continue}const f=l[Math.floor(Math.random()*l.length)];r=v(r,f,e),e=3-e}const{black:o,white:u}=G(r);return s===T?o>u?1:o===u?.5:0:u>o?1:u===o?.5:0}function j(n,t,s){const r=s.timeLimit??1e3,e=s.simulations??1e3,o=s.explorationConstant??1.4,u={board:n,children:[],untried:y(t,n),wins:0,visits:0,color:t},l=Date.now();let f=0;for(;Date.now()-l<r&&f<e;){let i=u;for(;i.untried.length===0&&i.children.length>0;)i=Z(i,o);if(i.untried.length>0){const d=Math.floor(Math.random()*i.untried.length),x=i.untried.splice(d,1)[0],k=v(i.board,x,i.color),D={board:k,move:x,parent:i,children:[],untried:y(3-i.color,k),wins:0,visits:0,color:3-i.color};i.children.push(D),i=D}const a=U(i.board,i.color,t);let m=i;for(;m;)m.visits+=1,m.wins+=a,m=m.parent;f++}let c=null,p=-1;for(const i of u.children)i.visits>p&&(p=i.visits,c=i.move??null);return c}self.onmessage=function(n){const{board:t,turn:s,level:r}=n.data,e=V(t,s,r);postMessage(e)}})();
