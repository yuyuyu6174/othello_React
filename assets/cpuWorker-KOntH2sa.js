(function(){"use strict";function X(n){let t=0,i=0;for(let r of n)for(let e of r)e===C?t++:e===P&&i++;return{white:t,black:i}}function z(n){const t=Array.from({length:h},()=>Array(h).fill(0)),i=[[1,0],[-1,0],[0,1],[0,-1],[1,1],[-1,-1],[1,-1],[-1,1]],r=(e,o,u)=>{for(let[l,m]of i){let c=e+l,p=o+m;for(;c>=0&&c<h&&p>=0&&p<h;){if(n[p][c]!==u)return!1;c+=l,p+=m}}return!0};for(let e=0;e<h;e++)for(let o=0;o<h;o++){const u=n[e][o];u!==W&&r(o,e,u)&&(t[e][o]=u)}return t}function B(n,t){const i=3-t;let r=0;for(let e=0;e<h;e++)for(let o=0;o<h;o++)n[e][o]===t?r++:n[e][o]===i&&r--;return r}function M(n,t,i={}){return q(n,t,i)}function T(n,t,i={}){return q(n,t,i)}function q(n,t,i={}){const r=3-t;let e=0;const o=i.weights??g.weights,u=i.useWeights!==!1,l=i.stableStoneBonus??g.stableStoneBonus,m=i.parityWeight??g.parityWeight,c=i.xSquarePenalty??g.xSquarePenalty,p=i.trapPenalty??g.trapPenalty;if(u)for(let s=0;s<h;s++)for(let a=0;a<h;a++){const f=n[s][a];f===t?e+=o[s][a]:f===r&&(e-=o[s][a])}if(i.evaluateStableStones){const s=z(n);for(let a=0;a<h;a++)for(let f=0;f<h;f++)s[a][f]===t?e+=l:s[a][f]===r&&(e-=l)}if(i.considerParity&&n.flat().filter(a=>a===W).length<=16){const a=X(n),f=t===C?a.white-a.black:a.black-a.white;e+=m*Math.sign(f)}if(i.penalizeXSquare){const s=[[1,1],[6,1],[1,6],[6,6]];for(const[a,f]of s)n[f][a]===t&&(e-=c),n[f][a]===r&&(e+=c)}if(i.avoidCornerTrap){const s=[[0,1],[1,0],[1,1],[0,6],[1,7],[1,6],[6,0],[6,1],[7,1],[6,6],[6,7],[7,6]];for(const[a,f]of s)n[f][a]===t&&(e-=p),n[f][a]===r&&(e+=p)}return e}const h=8,W=0,P=1,C=2,g={visible:!0,depth:2,weights:[[100,-25,10,5,5,10,-25,100],[-25,-50,1,1,1,1,-50,-25],[10,1,3,2,2,3,1,10],[5,1,2,1,1,2,1,5],[5,1,2,1,1,2,1,5],[10,1,3,2,2,3,1,10],[-25,-50,1,1,1,1,-50,-25],[100,-25,10,5,5,10,-25,100]],parityWeight:40,stableStoneBonus:20,xSquarePenalty:30,trapPenalty:30,endgame:{maxEmpty:12,usePruning:!0}},A={1:{visible:!0,name:"弱",comment:"浅い読みとシンプルな評価（初心者向け）",type:"minimax",depth:1,evaluator:B},2:{visible:!0,name:"中",comment:"標準的な深さのミニマックス探索",type:"minimax",depth:2,evaluator:B},3:{visible:!0,name:"強",comment:"さらに深い探索で安定したプレイ",type:"minimax",depth:3,evaluator:B},4:{visible:!0,name:"最強",comment:"深さ6の高精度ミニマックス探索（実践向け）",type:"minimax",depth:6,evaluator:M,useWeights:!0,avoidCornerTrap:!0,penalizeXSquare:!0},101:{visible:!0,name:"AI Test1",comment:"戦略評価を導入",type:"minimax",depth:8,evaluator:M,useWeights:!0,avoidCornerTrap:!0,evaluateStableStones:!0,considerParity:!0,penalizeXSquare:!0},102:{visible:!0,name:"AI Test2",comment:"残りマス数に応じて深さを調整（動的読み）",type:"minimax",dynamicDepth:!0,depthTable:[{max:20,depth:8},{max:40,depth:6},{max:64,depth:5}],evaluator:M,useWeights:!0,avoidCornerTrap:!0,evaluateStableStones:!0,considerParity:!0,penalizeXSquare:!0},103:{visible:!0,name:"AI Test3",comment:"反復深化探索（時間制限あり）",type:"iterative",timeLimit:1500,evaluator:M,useWeights:!0,avoidCornerTrap:!0,evaluateStableStones:!0,considerParity:!0,penalizeXSquare:!0},104:{visible:!0,name:"AI Test4",comment:"MCTS（モンテカルロ木探索）を使用",type:"mcts",simulations:1e3,timeLimit:1500,explorationConstant:1.1,evaluator:T,useWeights:!0,avoidCornerTrap:!0,evaluateStableStones:!0,considerParity:!0,penalizeXSquare:!0,parityWeight:50,stableStoneBonus:30,xSquarePenalty:60},105:{visible:!1,name:"AI Test5",comment:"評価カスタムを実装",type:"minimax",dynamicDepth:!0,depthTable:[{max:20,depth:9},{max:40,depth:7},{max:64,depth:6}],evaluator:T,useWeights:!0,weights:[[100,-40,20,5,5,20,-40,100],[-40,-80,-1,-1,-1,-1,-80,-40],[20,-1,5,1,1,5,-1,20],[5,-1,1,0,0,1,-1,5],[5,-1,1,0,0,1,-1,5],[20,-1,5,1,1,5,-1,20],[-40,-80,-1,-1,-1,-1,-80,-40],[100,-40,20,5,5,20,-40,100]],avoidCornerTrap:!0,evaluateStableStones:!0,considerParity:!0,penalizeXSquare:!0,parityWeight:40,stableStoneBonus:20,xSquarePenalty:50,useEndgameSolver:!0,endgame:{maxEmpty:12,usePruning:!0}},106:{visible:!0,name:"AI Test6",comment:"残り16マスになると完全終局読みを使用",type:"minimax",dynamicDepth:!0,depthTable:[{max:20,depth:8},{max:40,depth:6},{max:64,depth:5}],evaluator:M,useWeights:!0,avoidCornerTrap:!0,evaluateStableStones:!0,considerParity:!0,penalizeXSquare:!0,useEndgameSolver:!0,endgame:{maxEmpty:16,usePruning:!0}},107:{visible:!0,name:"AI Test7",comment:"高度なAI",type:"iterative",timeLimit:1500,evaluator:T,useWeights:!0,avoidCornerTrap:!0,evaluateStableStones:!0,considerParity:!0,penalizeXSquare:!0,parityWeight:60,stableStoneBonus:30,xSquarePenalty:60,trapPenalty:40,useEndgameSolver:!0,endgame:{maxEmpty:12,usePruning:!0}},999:{visible:!0,name:"Noob",comment:"最深読みと戦略フル活用。",type:"minimax",dynamicDepth:!0,depthTable:[{max:20,depth:9},{max:40,depth:7},{max:64,depth:6}],evaluator:T,useWeights:!0,weights:[[100,-40,20,5,5,20,-40,100],[-40,-80,-1,-1,-1,-1,-80,-40],[20,-1,5,1,1,5,-1,20],[5,-1,1,0,0,1,-1,5],[5,-1,1,0,0,1,-1,5],[20,-1,5,1,1,5,-1,20],[-40,-80,-1,-1,-1,-1,-80,-40],[100,-40,20,5,5,20,-40,100]],avoidCornerTrap:!0,evaluateStableStones:!0,considerParity:!0,penalizeXSquare:!0,parityWeight:60,stableStoneBonus:30,xSquarePenalty:60,trapPenalty:40,useEndgameSolver:!0,endgame:{maxEmpty:12,usePruning:!0}}},S=8,L=0,N=1,$=2,O=[[1,0],[-1,0],[0,1],[0,-1],[1,1],[-1,-1],[1,-1],[-1,1]];function _(n,t,i,r){if(r[t][n]!==L)return[];const e=[],o=3-i;for(const[u,l]of O){let m=n+u,c=t+l;const p=[];for(;m>=0&&m<S&&c>=0&&c<S&&r[c][m]===o;)p.push([m,c]),m+=u,c+=l;m>=0&&m<S&&c>=0&&c<S&&r[c][m]===i&&e.push(...p)}return e}function F(n,t){const i=[];for(let r=0;r<S;r++)for(let e=0;e<S;e++){const o=_(e,r,n,t);o.length>0&&i.push({x:e,y:r,flips:o})}return i}function y(n,t){return F(n,t)}function v(n,t,i){const r=n.map(e=>[...e]);r[t.y][t.x]=i;for(const[e,o]of t.flips)r[o][e]=i;return r}function G(n){let t=0,i=0;for(const r of n)for(const e of r)e===N?t++:e===$&&i++;return{black:t,white:i}}const I=new Map,w=new Map;function V(n,t,i){const r=A[i]||A[1],e={...g,...r,endgame:{...g.endgame,...r.endgame||{}}},o=l=>e.evaluator(l,t,e),u=n.flat().filter(l=>l===0).length;if(e.useEndgameSolver&&e.endgame&&u<=(e.endgame.maxEmpty??12))return Y(n,t,e);if(e.type==="minimax"){const l=e.dynamicDepth?H(u,e.depthTable||[]):e.depth??g.depth??2;return J(n,t,l,o)}return e.type==="iterative"?K(n,t,e.timeLimit||1e3,o):e.type==="mcts"?j(n,t,e):null}function H(n,t){for(let i of t)if(n<=i.max)return i.depth;return 2}function J(n,t,i,r,e){const o=y(t,n);if(o.length===0)return null;let u=null,l=-1/0;for(const m of o){const c=v(n,m,t),p=b(c,3-t,i-1,-1/0,1/0,!1,r);p>l&&(l=p,u=m)}return u}function b(n,t,i,r,e,o,u,l){const m=JSON.stringify(n)+t+i;if(I.has(m))return I.get(m);const c=y(t,n);if(i===0||c.length===0){const s=u(n);return I.set(m,s),s}const p=c.map(s=>{const a=v(n,s,t),f=u(a);return{move:s,score:f}}).sort((s,a)=>o?a.score-s.score:s.score-a.score);if(o){let s=-1/0;for(const{move:a}of p){const f=v(n,a,t),d=b(f,3-t,i-1,r,e,!1,u);if(s=Math.max(s,d),r=Math.max(r,d),e<=r)break}return I.set(m,s),s}else{let s=1/0;for(const{move:a}of p){const f=v(n,a,t),d=b(f,3-t,i-1,r,e,!0,u);if(s=Math.min(s,d),e=Math.min(e,d),e<=r)break}return I.set(m,s),s}}function K(n,t,i,r,e){const o=y(t,n);let u=null,l=-1/0;const m=Date.now();let c=1;for(;Date.now()-m<i;){for(const p of o){const s=v(n,p,t),a=b(s,3-t,c,-1/0,1/0,!1,r);a>l&&(l=a,u=p)}c++}return u}function Y(n,t,i){const r=y(t,n);if(r.length===0)return null;let e=null,o=-1/0;const u=r.map(l=>{const m=v(n,l,t),c=i.evaluator(m,t,i);return{move:l,score:c}}).sort((l,m)=>m.score-l.score);for(const{move:l}of u){const m=v(n,l,t),c=-E(m,3-t,i,!1,-1/0,1/0);c>o&&(o=c,e=l)}return e}function E(n,t,i,r,e=-1/0,o=1/0){var p;const u=JSON.stringify(n)+t;if(w.has(u))return w.get(u);const l=y(t,n);if(l.length===0)if(y(3-t,n).length===0){const a=n.flat().filter(x=>x===P).length,f=n.flat().filter(x=>x===C).length,d=t===P?a-f:f-a;return w.set(u,d),d}else{const a=-E(n,3-t,i,!0,-o,-e);return w.set(u,a),a}const m=l.map(s=>{const a=v(n,s,t),f=i.evaluator(a,t,i);return{move:s,score:f}}).sort((s,a)=>a.score-s.score);let c=-1/0;for(const{move:s}of m){const a=v(n,s,t),f=-E(a,3-t,i,!1,-o,-e);if(c=Math.max(c,f),e=Math.max(e,f),e>=o||(p=i.endgame)!=null&&p.usePruning&&c>=64)break}return w.set(u,c),c}function Z(n,t){let i=-1/0,r=n.children[0];for(const e of n.children){const o=e.visits===0?1/0:e.wins/e.visits+t*Math.sqrt(Math.log(n.visits)/e.visits);o>i&&(i=o,r=e)}return r}function U(n,t,i){let r=n.map(l=>[...l]),e=t;for(;;){const l=y(e,r);if(l.length===0){if(y(3-e,r).length===0)break;e=3-e;continue}const m=l[Math.floor(Math.random()*l.length)];r=v(r,m,e),e=3-e}const{black:o,white:u}=G(r);return i===P?o>u?1:o===u?.5:0:u>o?1:u===o?.5:0}function j(n,t,i){const r=i.timeLimit??1e3,e=i.simulations??1e3,o=i.explorationConstant??1.4,u={board:n,children:[],untried:y(t,n),wins:0,visits:0,color:t},l=Date.now();let m=0;for(;Date.now()-l<r&&m<e;){let s=u;for(;s.untried.length===0&&s.children.length>0;)s=Z(s,o);if(s.untried.length>0){const d=Math.floor(Math.random()*s.untried.length),x=s.untried.splice(d,1)[0],k=v(s.board,x,s.color),D={board:k,move:x,parent:s,children:[],untried:y(3-s.color,k),wins:0,visits:0,color:3-s.color};s.children.push(D),s=D}const a=U(s.board,s.color,t);let f=s;for(;f;)f.visits+=1,f.wins+=a,f=f.parent;m++}let c=null,p=-1;for(const s of u.children)s.visits>p&&(p=s.visits,c=s.move??null);return c}self.onmessage=function(n){const{board:t,turn:i,level:r}=n.data,e=V(t,i,r);postMessage(e)}})();
