(function(){"use strict";function D(n){let t=0,i=0;for(let s of n)for(let e of s)e===P?t++:e===w&&i++;return{white:t,black:i}}function X(n){const t=Array.from({length:h},()=>Array(h).fill(0)),i=[[1,0],[-1,0],[0,1],[0,-1],[1,1],[-1,-1],[1,-1],[-1,1]],s=(e,o,a)=>{for(let[c,l]of i){let f=e+c,p=o+l;for(;f>=0&&f<h&&p>=0&&p<h;){if(n[p][f]!==a)return!1;f+=c,p+=l}}return!0};for(let e=0;e<h;e++)for(let o=0;o<h;o++){const a=n[e][o];a!==E&&s(o,e,a)&&(t[e][o]=a)}return t}function T(n,t){const i=3-t;let s=0;for(let e=0;e<h;e++)for(let o=0;o<h;o++)n[e][o]===t?s++:n[e][o]===i&&s--;return s}function x(n,t,i={}){return C(n,t,i)}function I(n,t,i={}){return C(n,t,i)}function C(n,t,i={}){const s=3-t;let e=0;const o=i.weights??d.weights,a=i.useWeights!==!1,c=i.stableStoneBonus??d.stableStoneBonus,l=i.parityWeight??d.parityWeight,f=i.xSquarePenalty??d.xSquarePenalty,p=i.trapPenalty??d.trapPenalty;if(a)for(let r=0;r<h;r++)for(let u=0;u<h;u++){const m=n[r][u];m===t?e+=o[r][u]:m===s&&(e-=o[r][u])}if(i.evaluateStableStones){const r=X(n);for(let u=0;u<h;u++)for(let m=0;m<h;m++)r[u][m]===t?e+=c:r[u][m]===s&&(e-=c)}if(i.considerParity&&n.flat().filter(u=>u===E).length<=16){const u=D(n),m=t===P?u.white-u.black:u.black-u.white;e+=l*Math.sign(m)}if(i.penalizeXSquare){const r=[[1,1],[6,1],[1,6],[6,6]];for(const[u,m]of r)n[m][u]===t&&(e-=f),n[m][u]===s&&(e+=f)}if(i.avoidCornerTrap){const r=[[0,1],[1,0],[1,1],[0,6],[1,7],[1,6],[6,0],[6,1],[7,1],[6,6],[6,7],[7,6]];for(const[u,m]of r)n[m][u]===t&&(e-=p),n[m][u]===s&&(e+=p)}return e}const h=8,E=0,w=1,P=2,d={visible:!0,depth:2,weights:[[100,-25,10,5,5,10,-25,100],[-25,-50,1,1,1,1,-50,-25],[10,1,3,2,2,3,1,10],[5,1,2,1,1,2,1,5],[5,1,2,1,1,2,1,5],[10,1,3,2,2,3,1,10],[-25,-50,1,1,1,1,-50,-25],[100,-25,10,5,5,10,-25,100]],parityWeight:40,stableStoneBonus:20,xSquarePenalty:30,trapPenalty:30,endgame:{maxEmpty:12,usePruning:!0}},q={1:{visible:!0,name:"弱",comment:"浅い読みとシンプルな評価（初心者向け）",type:"minimax",depth:1,evaluator:T},2:{visible:!0,name:"中",comment:"標準的な深さのミニマックス探索",type:"minimax",depth:2,evaluator:T},3:{visible:!0,name:"強",comment:"さらに深い探索で安定したプレイ",type:"minimax",depth:3,evaluator:T},4:{visible:!0,name:"最強",comment:"深さ6の高精度ミニマックス探索（実践向け）",type:"minimax",depth:6,evaluator:x,useWeights:!0,avoidCornerTrap:!0,penalizeXSquare:!0},101:{visible:!0,name:"AI Test1",comment:"戦略評価を導入",type:"minimax",depth:6,evaluator:x,useWeights:!0,avoidCornerTrap:!0,evaluateStableStones:!0,considerParity:!0,penalizeXSquare:!0},102:{visible:!0,name:"AI Test2",comment:"残りマス数に応じて深さを調整（動的読み）",type:"minimax",dynamicDepth:!0,depthTable:[{max:20,depth:7},{max:40,depth:5},{max:64,depth:4}],evaluator:x,useWeights:!0,avoidCornerTrap:!0,evaluateStableStones:!0,considerParity:!0,penalizeXSquare:!0},103:{visible:!0,name:"AI Test3",comment:"反復深化探索（時間制限あり）",type:"iterative",timeLimit:800,evaluator:x,useWeights:!0,avoidCornerTrap:!0,evaluateStableStones:!0,considerParity:!0,penalizeXSquare:!0},104:{visible:!0,name:"AI Test4",comment:"MCTS（モンテカルロ木探索）を使用",type:"mcts",simulations:1e3,timeLimit:800,explorationConstant:1.1,evaluator:I,useWeights:!0,avoidCornerTrap:!0,evaluateStableStones:!0,considerParity:!0,penalizeXSquare:!0,parityWeight:50,stableStoneBonus:30,xSquarePenalty:60},105:{visible:!1,name:"AI Test5",comment:"評価カスタムを実装",type:"minimax",dynamicDepth:!0,depthTable:[{max:20,depth:9},{max:40,depth:7},{max:64,depth:6}],evaluator:I,useWeights:!0,weights:[[100,-40,20,5,5,20,-40,100],[-40,-80,-1,-1,-1,-1,-80,-40],[20,-1,5,1,1,5,-1,20],[5,-1,1,0,0,1,-1,5],[5,-1,1,0,0,1,-1,5],[20,-1,5,1,1,5,-1,20],[-40,-80,-1,-1,-1,-1,-80,-40],[100,-40,20,5,5,20,-40,100]],avoidCornerTrap:!0,evaluateStableStones:!0,considerParity:!0,penalizeXSquare:!0,parityWeight:40,stableStoneBonus:20,xSquarePenalty:50,useEndgameSolver:!0,endgame:{maxEmpty:14,usePruning:!0}},106:{visible:!0,name:"AI Test6",comment:"残り12マスになると完全終局読みを使用",type:"minimax",dynamicDepth:!0,depthTable:[{max:20,depth:8},{max:40,depth:6},{max:64,depth:5}],evaluator:x,useWeights:!0,avoidCornerTrap:!0,evaluateStableStones:!0,considerParity:!0,penalizeXSquare:!0,useEndgameSolver:!0,endgame:{maxEmpty:12,usePruning:!0}},999:{visible:!0,name:"Noob",comment:"最深読みと戦略フル活用。",type:"minimax",dynamicDepth:!0,depthTable:[{max:20,depth:8},{max:40,depth:6},{max:64,depth:5}],evaluator:I,useWeights:!0,weights:[[100,-40,20,5,5,20,-40,100],[-40,-80,-1,-1,-1,-1,-80,-40],[20,-1,5,1,1,5,-1,20],[5,-1,1,0,0,1,-1,5],[5,-1,1,0,0,1,-1,5],[20,-1,5,1,1,5,-1,20],[-40,-80,-1,-1,-1,-1,-80,-40],[100,-40,20,5,5,20,-40,100]],avoidCornerTrap:!0,evaluateStableStones:!0,considerParity:!0,penalizeXSquare:!0,parityWeight:60,stableStoneBonus:30,xSquarePenalty:60,trapPenalty:40,useEndgameSolver:!0,endgame:{maxEmpty:12,usePruning:!0}}},S=8,z=0,L=1,N=2,$=[[1,0],[-1,0],[0,1],[0,-1],[1,1],[-1,-1],[1,-1],[-1,1]];function _(n,t,i,s){if(s[t][n]!==z)return[];const e=[],o=3-i;for(const[a,c]of $){let l=n+a,f=t+c;const p=[];for(;l>=0&&l<S&&f>=0&&f<S&&s[f][l]===o;)p.push([l,f]),l+=a,f+=c;l>=0&&l<S&&f>=0&&f<S&&s[f][l]===i&&e.push(...p)}return e}function F(n,t){const i=[];for(let s=0;s<S;s++)for(let e=0;e<S;e++){const o=_(e,s,n,t);o.length>0&&i.push({x:e,y:s,flips:o})}return i}function v(n,t){return F(n,t)}function y(n,t,i){const s=n.map(e=>[...e]);s[t.y][t.x]=i;for(const[e,o]of t.flips)s[o][e]=i;return s}function G(n){let t=0,i=0;for(const s of n)for(const e of s)e===L?t++:e===N&&i++;return{black:t,white:i}}const M=new Map;function O(n,t,i){const s=q[i]||q[1],e={...d,...s,endgame:{...d.endgame,...s.endgame||{}}},o=c=>e.evaluator(c,t,e),a=n.flat().filter(c=>c===0).length;if(e.useEndgameSolver&&e.endgame&&a<=(e.endgame.maxEmpty??12))return Y(n,t,e);if(e.type==="minimax"){const c=e.dynamicDepth?V(a,e.depthTable||[]):e.depth??d.depth??2;return H(n,t,c,o)}return e.type==="iterative"?K(n,t,e.timeLimit||1e3,o):e.type==="mcts"?U(n,t,e):null}function V(n,t){for(let i of t)if(n<=i.max)return i.depth;return 2}function H(n,t,i,s,e){const o=v(t,n);if(o.length===0)return null;let a=null,c=-1/0;for(const l of o){const f=y(n,l,t),p=b(f,3-t,i-1,-1/0,1/0,!1,s);p>c&&(c=p,a=l)}return a}function b(n,t,i,s,e,o,a,c){const l=JSON.stringify(n)+t+i;if(M.has(l))return M.get(l);const f=v(t,n);if(i===0||f.length===0){const r=a(n);return M.set(l,r),r}const p=f.map(r=>{const u=y(n,r,t),m=a(u);return{move:r,score:m}}).sort((r,u)=>o?u.score-r.score:r.score-u.score);if(o){let r=-1/0;for(const{move:u}of p){const m=y(n,u,t),g=b(m,3-t,i-1,s,e,!1,a);if(r=Math.max(r,g),s=Math.max(s,g),e<=s)break}return M.set(l,r),r}else{let r=1/0;for(const{move:u}of p){const m=y(n,u,t),g=b(m,3-t,i-1,s,e,!0,a);if(r=Math.min(r,g),e=Math.min(e,g),e<=s)break}return M.set(l,r),r}}function K(n,t,i,s,e){const o=v(t,n);let a=null,c=-1/0;const l=Date.now();let f=1;for(;Date.now()-l<i;){for(const p of o){const r=y(n,p,t),u=b(r,3-t,f,-1/0,1/0,!1,s);u>c&&(c=u,a=p)}f++}return a}function Y(n,t,i){const s=v(t,n);if(s.length===0)return null;let e=null,o=-1/0;for(const a of s){const c=y(n,a,t),l=-B(c,3-t,i);l>o&&(o=l,e=a)}return e}function B(n,t,i,s){var a;const e=v(t,n);if(e.length===0)if(v(3-t,n).length===0){const l=n.flat().filter(p=>p===w).length,f=n.flat().filter(p=>p===P).length;return t===w?l-f:f-l}else return-B(n,3-t,i);let o=-1/0;for(const c of e){const l=y(n,c,t),f=-B(l,3-t,i);if(o=Math.max(o,f),(a=i.endgame)!=null&&a.usePruning&&o>=64)break}return o}function Z(n,t){let i=-1/0,s=n.children[0];for(const e of n.children){const o=e.visits===0?1/0:e.wins/e.visits+t*Math.sqrt(Math.log(n.visits)/e.visits);o>i&&(i=o,s=e)}return s}function J(n,t,i){let s=n.map(c=>[...c]),e=t;for(;;){const c=v(e,s);if(c.length===0){if(v(3-e,s).length===0)break;e=3-e;continue}const l=c[Math.floor(Math.random()*c.length)];s=y(s,l,e),e=3-e}const{black:o,white:a}=G(s);return i===w?o>a?1:o===a?.5:0:a>o?1:a===o?.5:0}function U(n,t,i){const s=i.timeLimit??1e3,e=i.simulations??1e3,o=i.explorationConstant??1.4,a={board:n,children:[],untried:v(t,n),wins:0,visits:0,color:t},c=Date.now();let l=0;for(;Date.now()-c<s&&l<e;){let r=a;for(;r.untried.length===0&&r.children.length>0;)r=Z(r,o);if(r.untried.length>0){const g=Math.floor(Math.random()*r.untried.length),W=r.untried.splice(g,1)[0],A=y(r.board,W,r.color),k={board:A,move:W,parent:r,children:[],untried:v(3-r.color,A),wins:0,visits:0,color:3-r.color};r.children.push(k),r=k}const u=J(r.board,r.color,t);let m=r;for(;m;)m.visits+=1,m.wins+=u,m=m.parent;l++}let f=null,p=-1;for(const r of a.children)r.visits>p&&(p=r.visits,f=r.move??null);return f}self.onmessage=function(n){const{board:t,turn:i,level:s}=n.data,e=O(t,i,s);postMessage(e)}})();
